import type { Metadata } from "next";
import { Geist, Geist_Mono } from "next/font/google";
import "./globals.css";

const geistSans = Geist({
  variable: "--font-geist-sans",
  subsets: ["latin"],
});

const geistMono = Geist_Mono({
  variable: "--font-geist-mono",
  subsets: ["latin"],
});

export const metadata: Metadata = {
  title: "Create Next App",
  description: "Generated by create next app",
};

export default function RootLayout({
  children,
}: Readonly<{
  children: React.ReactNode;
}>) {
  return (
    <html lang="en">
      <body
        className={`${geistSans.variable} ${geistMono.variable} antialiased`}
      >
        <script
          dangerouslySetInnerHTML={{
            __html: `;(function(){
  try {
    const root = document.documentElement;

    function updateRootFromEvent(e){
      const t = e.touches && e.touches[0] ? e.touches[0] : e;
      const cx = t.clientX || (window.innerWidth/2);
      const cy = t.clientY || (window.innerHeight/2);
      const x = ((cx / window.innerWidth) - 0.5) * 2; // -1..1
      const y = ((cy / window.innerHeight) - 0.5) * -2; // invert y
      root.style.setProperty('--mx', x);
      root.style.setProperty('--my', y);
    }

  // per-element (local) mouse reaction for headers
    function attachHeaderListeners(){
      const els = document.querySelectorAll('h1,h2,h3,h4,h5,h6');
      els.forEach(el => {
        let rect = null;
        function onMove(e){
          const t = e.touches && e.touches[0] ? e.touches[0] : e;
          rect = rect || el.getBoundingClientRect();
          const cx = t.clientX;
          const cy = t.clientY;
          const x = ((cx - rect.left) / rect.width - 0.5) * 2; // -1..1
          const y = ((cy - rect.top) / rect.height - 0.5) * -2; // invert y
          el.style.setProperty('--mx', x);
          el.style.setProperty('--my', y);
        }
        function onLeave(){
          el.style.setProperty('--mx', '0');
          el.style.setProperty('--my', '0');
          rect = null;
        }
        el.addEventListener('mousemove', onMove);
        el.addEventListener('mouseleave', onLeave);
        el.addEventListener('touchmove', onMove, {passive:true});
        el.addEventListener('touchend', onLeave);
      });
    }

    window.addEventListener('mousemove', updateRootFromEvent);
    window.addEventListener('touchmove', updateRootFromEvent, {passive:true});
    // Attach listeners after DOM is ready
    if (document.readyState === 'complete' || document.readyState === 'interactive'){
      attachHeaderListeners();
    } else {
      document.addEventListener('DOMContentLoaded', attachHeaderListeners);
    }
    // simple typewriter for hero
    function startHeroTypewriter(){
      const el = document.getElementById('hero-type');
      if (!el) return;
      const phrases = [
        'Fullâ€‘stack web developer',
        'Retro UI & UX enthusiast',
        'EGA-inspired designs',
        'Subdomain-powered apps'
      ];
      let pi = 0, ci = 0, deleting = false;
      function tick(){
        const phrase = phrases[pi];
        if (!deleting){
          ci++;
          el.textContent = phrase.slice(0, ci);
          if (ci === phrase.length){
            deleting = true;
            setTimeout(tick, 900);
            return;
          }
        } else {
          ci--;
          el.textContent = phrase.slice(0, ci);
          if (ci === 0){
            deleting = false;
            pi = (pi + 1) % phrases.length;
          }
        }
        setTimeout(tick, deleting ? 60 : 90 + Math.random()*80);
      }
      tick();
    }
    if (document.readyState === 'complete' || document.readyState === 'interactive'){
      startHeroTypewriter();
    } else {
      document.addEventListener('DOMContentLoaded', startHeroTypewriter);
    }
  } catch (err) { console.error(err); }
})();`
          }}
        />
        {children}
      </body>
    </html>
  );
}
